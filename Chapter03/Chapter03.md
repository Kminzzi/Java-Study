




# Chapter03. 연산자 (operator)

###   :memo: 작성 날짜 : 2022-12-14
###  :tada: 작성자 : KMinzzi   

<br/>

## 1. 연산자
- 연산자 : 연산을 수행하는 기호
</br>

### 1.1 연산자와 피연산자
- 연산자 (operator) 연산을 수행하는 기호 (+, -, *, / 등)
- 피연산자 (operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
</br>

### 1.2 식과 대입연산자
- 식 : 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것
- 대입 연산자 : =
</br>

### 1.3 연산자의 종류
|종류|연산자|설명|
|:-:|:-:|:-:|
|산술 연산자|+ - * / % << >> | 사칙연산과 나머지 연산(%)
|비교 연산자|> < >= <= == != |크고 작음과 같고 다름을 비교
|논리 연산자|&& II ! & I ^ ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결
|대입 연산자|=|우변의 값을 좌변에 저장
|기타|(type) ? : instanceof|형변환 연산자, 삼항 연산자, instanceof 연산자
<br/>

### 1.4 연산자의 우선순위와 결합

#### 연산자의 우선순위
|종류|결합규칙|연산자|우선순위|
|:-:|:-:|:-:|:-:|
|단항연산자|<---|++ -- + - ~ ! (type) | 높음
|산술연산자|--->|* / % |
||--->|+ -|
||--->|<< >> |
|비교연산자|--->|< > <= >= instanceof |
||--->|== != |
|논리 연산자|--->|& ^ I && II |
|삼항 연산자|<---|? :|
|대입 연산자|<---|= += -= *= /= %= <<= >>= &= ^= I= |낮음
<br/>

### 1.5 산술 변환(usual arithmetic conversion)
```
int i = 10;
float f = 20.0f;

float result = f + (float) i;
float result = f+ i; 			//큰 타입으로 형 변환 시, 형변환연산자 생략 가능
```
연산 전에 피연산자 타입의 일치를 위해 자동 형변환 되는 것을 '산술 변환' 또는 '일반 산술 변환'이라 한다.


#### 산술 변환의 규칙
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
long + int ----> long + long ----> long
float + int ----> float + float ----> float
double + float ----> double + double ----> double


2. 피연산자의 타입이 int보다 작은 타입이면 int로 변한다.
byte + short ----> int + int ----> int 
char + short ----> int + int ----> int


첫 번째 규칙은 피연산자의 값 손실을 최소화 하기 위한 것이다.
두 번째 규칙은 int타입이 가장 효율적으로 처리할 수 있는 타입이기 때문이다.
```
ex) int / int ---> int
     5  /  2  --->  2
```
int형으로 변환하여 연산하기 때문에 2라는 값이 나온다. 여기서 2.5를 얻기 위해서는 (float)형식으로 형변환을 해야한다.

</br>
</br>

## 2. 단항 연산자

### 2.1 증감 연산자 ++ --

- 증감 연산자(++) : 피연산자의 값을 1증가시킨다.
- 감소 연산자(- -) : 피연산자의 값을 1감소 시킨다.

#### 전위형과 후위형의 비교

단항 연산자는 피연산자의 양쪽 모두 가능하다. 왼쪽에 위치하면 **전위형**, 오른쪽에 위치하면 **후위형**이라고 한다.

|타입|설명|사용예
|:-:|:-:|:-:|
|전위형|값이 참조되기 **전**에 증가시킨다.|j = ++i;|
|후위형|값이 참조된 **후**에 증가시킨다.|j = i++;|

#### 예제
```
class OperatorEx2{
	public static void main(String args[]) {
		
		int i=5, j=0;
		
		j=i++;
		System.out.println("j=i++; 실행 후, i=" + i + ", j=" + j);
		
		i=5;
		j=0;
		
		j=++i;
		System.out.println("j=++i; 샐행 후, i=" + i + ", j=" + j);
	}
}
```
#### 실행결과
```
j=i++; 실행 후, i=6, j=5
j=++i; 실행 후, i=6, j=6
```

전위형은 변수(피연산자)의 값을 먼저 증가시킨 후에 변수의 값을 읽어온다.
후위형은 변수의 값을 먼저 읽어온 후에 값을 증가한다.

```
j=++i;  	//전위형 	---->  ++i;			// 증가 후에
							   j=i;			// 참조하여 대입
```

```
j=i++;  	//후위형 	---->  j=i;			// 참조하여 대입 후에
							   i++;			// 증가
```
</br>

### 2.2 부호 연산자 + -

부호 연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다.
부호 연산자 '+'는 형식적으로 추가해놓은 것이다.

부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용가능하다.

</br>
</br>

## 3. 산술 연산자

### 3.1 사칙연산자 + - * /
사칙 연산자는 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/)이 있다.
곱셈, 나눗셈, 나머지 연산자가 덧셈, 뺄셈 연산자보다 우선순위가 높으므로 먼저 처리된다.

#### 예제 1
```
class OperatorEx5 {
	public static void main(String args[]) {
		
		int a=10;
		int b=4;
		
		System.out.printf("%d + %d = %d%n", a, b, a+b);
		System.out.printf("%d - %d = %d%n", a, b, a-b);
		System.out.printf("%d * %d = %d%n", a, b, a*b);
		System.out.printf("%d / %d = %d%n", a, b, a/b);
		System.out.printf("%d / %f = %f%n", a, (float)b, a/(float)b);
	}
}
```
#### 실행결과
```
10 + 4 = 14
10 - 4 = 6
10 * 4 = 40
10 / 4 = 2
10 / 4.000000 = 2.500000
```
a와 b를 나눈 결과가 2인 것은 연산 결과가 int 타입이기 때문에 소수점 이하는 버려지기 때문이다.

</br>

#### 예제 2
```
class OperatorEx10 {
	public static void main(String args[]) {
		char a='a';
		char d='d';
		
		char zero='0'
		char two='2';

		System.out.printf("'%c'-'%c'=%d%d", d, a, d-a);
		System.out.printf("'%c'-'%c'=%d%d", two, zero, two-zero);
		System.out.printf("'%c'=%d%n", a, (int)a);
		System.out.printf("'%c'=%d%n", d, (int)d);
		System.out.printf("'%c'=%d%n", zero, (int)zero);
		System.out.printf("'%c'=%d%n", two, (int)two);
	}
}
```

#### 실행결과
```
'd'-'a'=3
'2'-'0'=2
'a'=97
'd'=100
'0'=48
'2'=50
```

문자는 해당 문자의 유니코드로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다.
문자 '2'의 유니코드는 50이고, 문자 '0'은 48이므로 두 문자간의 뺄셈은 2를 결과로 얻는다.

</br>

#### 예제 3
```
class OperatorEx13 {
	public static void main(String[] args) {
		char c1='a';
	
//		char c2=c1+1;		//컴파일 에러 발생
		char c2='a'+1;

		System.out.println(c2);
	}
}
```

#### 실행결과
```
b
```
수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형변환을 해주어야 한다.
```
char c2=(char)(c1+1);
```

</br>

### 3.2 나머지 연산자 %
- 나머지 연산자 : 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자

**피연산자로 정수만 허용한다.**

```
public class OperatorEx20 {
	public  static  void main(String[] args) {
		System.out.println(-10%8);
		System.out.println(10%-8);
		System.out.println(-10%-8);
	}
}
```
#### 실행결과
```
-2
2
-2
```
나머지 연산자는 나누는 수로 음수도 허용한다. 다만 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 같다.

</br>

## 4. 비교 연산자
### 4.1 대소비교 연산자 < > <= >=
**두 피연산자의 값의 크기를 비교하는 연산자**
기본형 중에서는 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.
|비교연산자|연산결과|
|:-:|:-:|
|>|좌변 값이 크면, true 아니면 flase|
|<|좌변 값이 작으면, true 아니면 flase|
|>=|좌변 값이 크거나 같으면, true 아니면 flase|
|<=|좌변 값이 작거나 같으면, true 아니면 flase|

</br>

### 4.2 등가비교 연산자 == !=
**두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자**
기본형, 참조형, 즉 모든 자료형 사용가능하다.
|비교연산자|연산결과|
|:-:|:-:|
|==|두 값이 같으면 true, 아니면 false|
|!=| 값이 다르면 true, 아니면 false|
</br>
</br>

## 5. 논리 연산자
### 5.1 논리 연산자 - &&, ||, !
- || (OR결합) : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.
- && (AND결합) : 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.

|X|Y|X II Y | X && Y
|:-:|:-:|:-:|:-:|
|true|true|true|true|
|true|flase|true|false|
|false|true|true|false|
|false|false|false|false

### 논리 부정 연산자
피연산자가 true면, flase를, flase면 true를 결과로 반환한다.

|X|! X
|:-:|:-:|
|true|false|
|false|true|

## 5.2 비트 연산자  &  |  ^  ~  <<  >>

- | (OR연산자)	피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
- & (AND연산자)	피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
- ^ (XOR연산자)	피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.


|X|Y|X I Y | X & Y|X ^ Y
|:-:|:-:|:-:|:-:|:-:
|1|1|1|1|0|
|1|0|1|0|1|
|0|1|1|0|1|
|0|0|0|0|0|

#### 쉬프트 연산자   <<   >>
- 쉬프트 연산자 : 피연산자의 각 자리(2진수로 표현)를 '오른쪽(>>)' 또는 '왼쪽(<<)'으로 이동(shift)한다고 해서 이름이 붙여졌다. 또한, 속도가 매우 빠르나 가독성이 떨어진다.

ex) 8>>2 : 오른쪽으로 두번 이동한다.
1000(8) -> 0010(4)

</br>

## 6. 그 외의 연산자

### 6.1 조건 연산자 ? :
```
result = (x > y) ? x: y;
```
세 개의 피연산자를 필요로 하는 삼항 연산자로 x > y의 결과가 true라면, x의 값이 저장되고, false라면, y의 값이 저장된다.
</br>
