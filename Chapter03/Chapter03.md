



# Chapter03. 연산자 (operator)

###   :memo: 작성 날짜 : 2022-12-14
###  :tada: 작성자 : KMinzzi   

<br/>

## 1. 연산자
- 연산자 : 연산을 수행하는 기호
</br>

### 1.1 연산자와 피연산자
- 연산자 (operator) 연산을 수행하는 기호 (+, -, *, / 등)
- 피연산자 (operand) 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
</br>

### 1.2 식과 대입연산자
- 식 : 연산자와 피연산자를 조합하여 계산하고자 하는 바를 표현한 것
- 대입 연산자 : =
</br>

### 1.3 연산자의 종류
|종류|연산자|설명|
|:-:|:-:|:-:|
|산술 연산자|+ - * / % << >> | 사칙연산과 나머지 연산(%)
|비교 연산자|> < >= <= == != |크고 작음과 같고 다름을 비교
|논리 연산자|&& II ! & I ^ ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결
|대입 연산자|=|우변의 값을 좌변에 저장
|기타|(type) ? : instanceof|형변환 연산자, 삼항 연산자, instanceof 연산자
<br/>

### 1.4 연산자의 우선순위와 결합

#### 연산자의 우선순위
|종류|결합규칙|연산자|우선순위|
|:-:|:-:|:-:|:-:|
|단항연산자|<---|++ -- + - ~ ! (type) | 높음
|산술연산자|--->|* / % |
||--->|+ -|
||--->|<< >> |
|비교연산자|--->|< > <= >= instanceof |
||--->|== != |
|논리 연산자|--->|& ^ I && II |
|삼항 연산자|<---|? :|
|대입 연산자|<---|= += -= *= /= %= <<= >>= &= ^= I= |낮음
<br/>

### 1.5 산술 변환(usual arithmetic conversion)
```
int i = 10;
float f = 20.0f;

float result = f + (float) i;
float result = f+ i; 			//큰 타입으로 형 변환 시, 형변환연산자 생략 가능
```
연산 전에 피연산자 타입의 일치를 위해 자동 형변환 되는 것을 '산술 변환' 또는 '일반 산술 변환'이라 한다.


#### 산술 변환의 규칙
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
long + int ----> long + long ----> long
float + int ----> float + float ----> float
double + float ----> double + double ----> double


2. 피연산자의 타입이 int보다 작은 타입이면 int로 변한다.
byte + short ----> int + int ----> int 
char + short ----> int + int ----> int


첫 번째 규칙은 피연산자의 값 손실을 최소화 하기 위한 것이다.
두 번째 규칙은 int타입이 가장 효율적으로 처리할 수 있는 타입이기 때문이다.
```
ex) int / int ---> int
     5  /  2  --->  2
```
int형으로 변환하여 연산하기 때문에 2라는 값이 나온다. 여기서 2.5를 얻기 위해서는 (float)형식으로 형변환을 해야한다.

</br>
</br>

## 2. 단항 연산자

### 2.1 증감 연산자 ++ --

- 증감 연산자(++) : 피연산자의 값을 1증가시킨다.
- 감소 연산자(- -) : 피연산자의 값을 1감소 시킨다.

#### 전위형과 후위형의 비교

단항 연산자는 피연산자의 양쪽 모두 가능하다. 왼쪽에 위치하면 **전위형**, 오른쪽에 위치하면 **후위형**이라고 한다.

|타입|설명|사용예
|:-:|:-:|:-:|
|전위형|값이 참조되기 **전**에 증가시킨다.|j = ++i;|
|후위형|값이 참조된 **후**에 증가시킨다.|j = i++;|

#### 예제
```
class OperatorEx2{
	public static void main(String args[]) {
		
		int i=5, j=0;
		
		j=i++;
		System.out.println("j=i++; 실행 후, i=" + i + ", j=" + j);
		
		i=5;
		j=0;
		
		j=++i;
		System.out.println("j=++i; 샐행 후, i=" + i + ", j=" + j);
	}
}
```
#### 실행결과
```
j=i++; 실행 후, i=6, j=5
j=++i; 실행 후, i=6, j=6
```

전위형은 변수(피연산자)의 값을 먼저 증가시킨 후에 변수의 값을 읽어온다.
후위형은 변수의 값을 먼저 읽어온 후에 값을 증가한다.

```
j=++i;  	//전위형 	---->  ++i;			// 증가 후에
							   j=i;			// 참조하여 대입
```

```
j=i++;  	//후위형 	---->  j=i;			// 참조하여 대입 후에
							   i++;			// 증가
```
</br>

### 2.2 부호 연산자 + -

부호 연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다.
부호 연산자 '+'는 형식적으로 추가해놓은 것이다.

부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용가능하다.

</br>
</br>

## 3. 산술 연산자

### 3.1 사칙연산자 + - * /
사칙 연산자는 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/)이 있다.
곱셈, 나눗셈, 나머지 연산자가 덧셈, 뺄셈 연산자보다 우선순위가 높으므로 먼저 처리된다.

#### 예제 1
```
class OperatorEx5 {
	public static void main(String args[]) {
		
		int a=10;
		int b=4;
		
		System.out.printf("%d + %d = %d%n", a, b, a+b);
		System.out.printf("%d - %d = %d%n", a, b, a-b);
		System.out.printf("%d * %d = %d%n", a, b, a*b);
		System.out.printf("%d / %d = %d%n", a, b, a/b);
		System.out.printf("%d / %f = %f%n", a, (float)b, a/(float)b);
	}
}
```
#### 실행결과
```
10 + 4 = 14
10 - 4 = 6
10 * 4 = 40
10 / 4 = 2
10 / 4.000000 = 2.500000
```
a와 b를 나눈 결과가 2인 것은 연산 결과가 int 타입이기 때문에 소수점 이하는 버려지기 때문이다.

</br>

#### 예제 2
```
class OperatorEx10 {
	public static void main(String args[]) {
		char a='a';
		char d='d';
		
		char zero='0'
		char two='2';

		System.out.printf("'%c'-'%c'=%d%d", d, a, d-a);
		System.out.printf("'%c'-'%c'=%d%d", two, zero, two-zero);
		System.out.printf("'%c'=%d%n", a, (int)a);
		System.out.printf("'%c'=%d%n", d, (int)d);
		System.out.printf("'%c'=%d%n", zero, (int)zero);
		System.out.printf("'%c'=%d%n", two, (int)two);
	}
}
```

#### 실행결과
```
'd'-'a'=3
'2'-'0'=2
'a'=97
'd'=100
'0'=48
'2'=50
```

문자는 해당 문자의 유니코드로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다.
문자 '2'의 유니코드는 50이고, 문자 '0'은 48이므로 두 문자간의 뺄셈은 2를 결과로 얻는다.

</br>

#### 예제 3
```
class OperatorEx13 {
	public static void main(String[] args) {
		char c1='a';
	
//		char c2=c1+1;		//컴파일 에러 발생
		char c2='a'+1;

		System.out.println(c2);
	}
}
```

#### 실행결과
```
b
```
수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형변환을 해주어야 한다.
```
char c2=(char)(c1+1);
```

</br>

### 3.2 나머지 연산자 %
- 나머지 연산자 : 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자

**피연산자로 정수만 허용한다.**

```
public class OperatorEx20 {
	public  static  void main(String[] args) {
		System.out.println(-10%8);
		System.out.println(10%-8);
		System.out.println(-10%-8);
	}
}
```
#### 실행결과
```
-2
2
-2
```
나머지 연산자는 나누는 수로 음수도 허용한다. 다만 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 같다.

</br>

## 4. 비교 연산자
### 4.1 대소비교 연산자 < > <= >=
**두 피연산자의 값의 크기를 비교하는 연산자**
기본형 중에서는 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.
|비교연산자|연산결과|
|:-:|:-:|
|>|좌변 값이 크면, true 아니면 flase|
|<|좌변 값이 작으면, true 아니면 flase|
|>=|좌변 값이 크거나 같으면, true 아니면 flase|
|<=|좌변 값이 작거나 같으면, true 아니면 flase|

</br>

### 4.2 등가비교 연산자 == !=
**두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자**
기본형, 참조형, 즉 모든 자료형 사용가능하다.
|비교연산자|연산결과|
|:-:|:-:|
|==|두 값이 같으면 true, 아니면 false|
|!=| 값이 다르면 true, 아니면 false|
</br>

### 4.3 정수형 - byte, short, int, long

byte(1)  <  short(2)  <  int(4)  <  long(8)

|자료형|저장 가능한 값의 범위|크기||
|:-:|:-:|:-:|:-:|
|||bit|byte|
|byte|-128~127(-2^7^ ~ 2^7^ -1)|8|1
|short|(-2^15^ ~ 2^15^ -1)|16|2
|int|(-2^31^ ~ 2^31^ -1)|32|4
|long|(-2^63^ ~ 2^63^ -1)|64|8

</br>

### 4.4 실수형 - float, double
|자료형|저장 가능한 값의 범위|정밀도|크기||
|:-:|:-:|:-:|:-:|:-:
||||bit|byte|
|float|1.4 X 10^-45^ ~ 3.4 X 10^38^|7자리|32|4
|double|14.9 X 10^-324^ ~ 1.8 X 10^308^|15자리|64|8
</br>
</br>

## 5. 형변환

### 5.1 형변환(캐스팅, casting) 이란?

- 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
</br>
 
 ### 5.2 형변환 방법
 ```
 (타입) 피연산자
 ```
 ```
 double d = 85.4;
 int score = (int)d;
 ```
 ```
 int score = (int)d;
 -> int score = (int)85.4;		// 변수 d의 값을 읽어 와서 형변환한다.
 -> int score = 85;				// 형변환의 결과인 85를 변수 score에 저장한다.
 ```
 </br>
 
 ### 5.3 정수형간의 형변환
 > 큰타입에서 작은 타입으로의 변환
 
 int의 값을 byte타입으로 변환하는 경우 크기의 차이만큼 잘려나가 '값 손실(loss of data)'이 발생할 수 있다.
> 작은 타입에서 큰 타입으로의 변환

byte타입의 값을 int타입으로 변환하는 경우 저장공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않으며 나머지 빈 공간은 0 또는 1로 채워진다.

</br>
 
 ### 5.3 실수형 간의 형변환
  > 큰타입에서 작은 타입으로의 변환

double타입의 값을 float로 변환하는 경우, 지수(E)는 double의 기저인 1023을 뺀 후, float의 기저인 127을 더하고 가수(M)는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려진다.

> 작은 타입에서 큰 타입으로의 변환

float타입의 값을 double로 변환하는 경우, 빈 공간을 0으로 채운다.

<br/>
